main    mov r9, #0x500; pocetak strukture
        ldr r4, maska; r4 je oznaka za kraj strukture podataka za load
        ldr r5, zapis; pocetak odakle se zapisuju rezultati
        ldr r12, krajzap; loadanje adrese za kraj zapisa
        mov r10, #0; ako se dijeli s nulom pa cemo to upisivat
        ;str r12, [r10]; registar za kraj zapisa operacija
        mov sp, #0x10000; inicijalizacija stoga

petlja  ldr r1, [r9]
        cmp r1, r4
        beq kraj
        ldr r1, [r9], #4; ucitavanje prvog clana
        ldr r2, [r9], #4; ucitavanje drugog clana
        ldr r3, [r9], #4; ucitavanje treceg clana
        
        cmp r1, #0x0; provjera je li zbrajanje
        beq zbr

        cmp r1, #0x1; provjera je li oduzimanje
        beq odu

        cmp r1, #0x2; provjera je li mnozenje
        beq mno

        ;cmp r1, #0x3; provjera je li dijeljenje(nije potrebno jer je ovo zadnji uvjet)
        bl DIJELI

        b petlja
        
     
zbr     add r6, r2, r3; zbrajanje (koristi registar 6)
        str r6, [r5], #4; spremi rezultat u r5 i pomakni ga za 32b
        b petlja; vraca na pocetak petlje

odu     sub r7, r2, r3; oduzimanje (koristi registar 7)
        str r7, [r5], #4; spremi rezultat u r5 i pomakni ga za 32b
        b petlja;

mno     mul r8, r2, r3; mnozenje (koristi registar 8)
        str r8, [r5], #4; spremi rezultat u r5 i pomakni ga za 32b
        b petlja;

DIJELI  ;stog je inicijaliziran na pocetku koda
        stmfd sp!, {r1, r2, r3, r10, r11} ;kontekst
        mov r0, #0; rjesenje
        mov r11, #0; predznak

        cmp r2, #0; provjera jeli djeljenik nula
        ; jer ako je nema smisla dijelit i odmah izlazimo
        streq r10, [r5], #4;
        beq petlja; vrati se na pocetak petlje za ucitavanje 3 zadana broja u bloku
        mvnmi r2, r2; ak je djeljenik negativan
        addmi r2, r2, #1; pretvorba u pozitivan
        eormi r11, r11, #1 ; predznak

        cmp r3, #0 ;provjera je li djelitelj nula, jer ako je upisujemo nulu
        streq r10, [r5], #4; i vracamo se u petlju
        beq petlja
        mvnmi r3, r3 ;ako je djelitelj negativan
        addmi r3, r3, #1; napravi da bude nenegativan
        eormi r11, r11, #1; predznak

for     subs r2, r2, r3;
        addge r0, r0, #1 ;ako je r2 >= r3, povecaj brojac dijeljenja
        bhi for
        
        cmp r11, #1
        mvneq r0, r0 ;ovisno o predznaku, radimo predznak rezultata
        addeq r0, r0, #1  
        
        ; tu je kraj za DIJELI
        ldmfd sp!, {r1, r2, r3, r10, r11}
        str r0, [r5], #4
        mov pc, lr    

kraj    str r12, [r5], #4; oznaka kraja zapisa sa danom adresom
        swi 0x123456

maska dw 0x80808080
zapis dw 0x1000
krajzap dw 0xFFFFFFFF


 org 0x500
 DW 0x3, 0xFFFFFEFF, 0x00000010
 dw 0x00000003, 0xFFFFF000, 0x00000000 ;djelitelj nula
 dw 0x00000003, 0x00000000, 0x00000001 ;djeljenik nula
 dw 0x00000003, 0x00000000, 0x00000000 ;oboje nula
 dw 0x00000003, 0xFFFFFEFF, 0x00000010
 dw 0x00000001, 0x000001F4, 0xFFFFFD44
 dw 0x00000002, 0xFFFFFFFE, 0x0000000A
 dw 0x00000003, 0xFFFFF000, 0xFFFFFFC0
 ;od anonimnog test caseovi
 DW 0x3, 0xFFFFFEFF, 0x00000010     ; -257 / 16 = -16 0xFFFF FFF0
 DW 0x1, 0x1F4, 0xFFFFFD44          ; 500 - (-700) = 1200 0x0000 04B0
 DW 0x2, 0xFFFFFFFE, 0xA            ; -2 * 10 = -20 0xFFFF FFEC
 DW 0x3, 0xFFFFF000, 0xFFFFFFC0     ; -4096 / -64 = 64 0x0000 0040
 DW 0x3, 0xA, 0x2                   ; 10 / 2 = 5 0x0000 0005
 DW 0x3, 0xFFFFFFF6, 0xFFFFFFFE     ; -10 / -2 = 5 0x0000 0005
 DW 0x2, 0xFFFFFFFB, 0x4            ; -5 * 4 = -20 0xFFFF FFEC
 DW 0x1, 0xFFFFFFFC, 0x5            ; -4 - 5 = -9 0xFFFF FFF7
 DW 0x3, 0xFFFFFEAF, 0x110010       ; -337 / 1114128 = 0 0x0000 0000
 DW 0x1, 0x211F4, 0xFAFBFD44        ; 135668 - (-84148924) = 84284592 0x0506 14B0
 DW 0x2, 0xFFFBBFFE, 0x2300A        ; -278530 * 143370 = -39932846100, not in 32 bits, undefined behaviour (0xB3D1 1FEC)
 DW 0x3, 0xF7F4F200, 0xFF34FFC0     ; -134942208 / -13303872 = 10 0x0000 000A
 dw 0x80808080


